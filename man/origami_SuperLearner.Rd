% Generated by roxygen2 (4.1.0): do not edit by hand
% Please edit documentation in R/origami_SuperLearner.R
\name{cv_SL}
\alias{cv_SL}
\alias{origami_SuperLearner}
\title{origami_SuperLearner}
\usage{
cv_SL(fold, Y, X, SL.library, family, obsWeights, id, ...)

origami_SuperLearner(Y, X, newX = NULL, SL.library, family = gaussian(),
  obsWeights = rep(1, length(Y)), id = NULL, folds = NULL,
  method = method.NNLS(), cvfun = cv_SL, ...)
}
\arguments{
\item{fold}{a Fold to be passed to cv_SL.}

\item{Y}{vector of outcomes.}

\item{X}{vector of covariates.}

\item{SL.library}{character vector of learner names.}

\item{family}{Either gaussian() or binomial() depending on if Y is binary or continuous.}

\item{obsWeights}{vector of weights.}

\item{id}{vector of ids.}

\item{...}{other arguments passed to the underlying call to \code{\link{cross_validate}}}

\item{newX}{currently ignored.}

\item{folds}{a list of Folds. See \code{\link{make_folds}}. If missing,
will be created based on Y and cluster_ids.}

\item{method}{a combination method. Typically either method.NNLS or method.NNloglik.}

\item{cvfun}{the function to be run at each cross-validation step. Changing this allows,
for example, dynamic creation of fold-specific data. Must have same prototype as cv_SL}
}
\description{
SuperLearner implemented using orgami cross-validation. Leverages a lot of code from Eric Polley's
SuperLearner package. Because of it's based on origami, we get two features for free:
foreach based parallelization, and support for arbitrary cross-validation schemes.
Note, while this is a working SuperLearner implementation, it is intended more as an example
than production code. As such, it is subject to change in the future.
}
\examples{
N <- 200
p <- 40
X <- matrix(rnorm(N * p), N, p)
X <- as.data.frame(X)
Y <- rbinom(N, 1, plogis(0.2 * X[, 1] + 0.1 * X[, 2] - 0.2 * X[, 3] +
                           0.1 * X[, 3] * X[, 4] - 0.2 * abs(X[, 4])))

SL.library <- c("SL.glmnet", "SL.glm", "SL.knn_stored", "SL.gam", "SL.mean")

folds <- make_folds(X)

# Original SuperLearner convert folds into the form SuperLearner will accept
vfolds <- lapply(folds, function(fold) {
    validation(fold = fold)
})

set.seed(1)  #cv in glmnet is randomized so we have to set a seed to consistent results
sl_result <- SuperLearner(Y = Y, X = X, SL.library = SL.library, method = method.NNLS(), 
                          family = binomial(), cvControl = list(validRows = vfolds))



# Origami SuperLearner
set.seed(1)  #cv in glmnet is randomized so we have to set a seed to consistent results
osl_result <- origami_SuperLearner(Y = Y, X = X, SL.library = SL.library, method = method.NNLS(), 
                                   family = binomial(), folds = folds)

# compare results
equal_values <- function(e1, e2) {all.equal(e1, e2, check.attributes = FALSE, use.names=FALSE)}
equal_values(sl_result$cvRisk, osl_result$cvRisk)
equal_values(sl_result$coef, osl_result$coef)
equal_values(sl_result$SL.predict, predict(osl_result$fullFit, newdata = X)$pred)
}
\seealso{
\code{\link{predict.origami_SuperLearner}}
}

